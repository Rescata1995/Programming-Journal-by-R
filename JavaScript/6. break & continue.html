<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Break & Continue</title>
</head>
<body>
    <script>
        // En esta ocasión, vamos a profundizar más sobre las sentencias "break" & "continue"; como bien puede imaginarse, ambas nos ayudan a controlar el flujo de nuestro código, especialmente en estructuras repetitivas (loops); de tal manera que seamos nosotros, los programadores, los que determinemos hasta qué punto queremos que la estructura (nuestro código) deje de correr o ejecutarse (o, en el caso de los loops, deje de iterarse). Hay casos más interesantes donde, si bien, no se corta o se detiene toda la estructura de código que se está corriendo; mas, sí puede seleccionar puntos en especifico, de la estructura de código misma, donde no quiere que se corra o se ejecute (que se salte una parte o varias de la estructura); esto, generalmente, en base a un patrón lógico que deseemos cumplir. Por ejemplo, las sentencias "break & continue" pueden aplicarse en el caso hipotetico que, de una lista de números ordenada, queramos sólo imprimir los números pares; es decir, que de dicha lista, y asistiendose de un bucle, se haga un salto (en la estructura) iteracción de por medio y se reflejen como salida sólo los números pares (dejando por fuera los impares). Veamos el mismo anterior caso.

        // Algo que ya hemos aclarado, aunque implicitamente, se dejará claro ahora sin titubeos: Las sentencias "break & continue" sólo se pueden aplicar sobre estructuras ciclicas y/o de control; mas no directamente sobre algún tipo de dato, ya sea primario o compuesto.

        const numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]

        for (let i= 0; i < numeros.length; i++){
            console.log(numeros[i]);
        }

        // La anterior estructura nos imprime todos los elementos del arreglo "numeros"; es decir, todo el listado de números que van desde el primer elemento, 1, hasta el último elemento: 0. 

        // Ahora si por ejemplo, de la misma estructura ciclica (y con la misma condición), queremos imprimir sólo hasta el número 4,... nos podemos asistir de la sentencia "break", tal que así:

        for (let i= 0; i < numeros.length; i++){
            if (numeros[i] === 5){
                break;
            }

            // La orden es la siguiente: Apenas el incremento del arreglo "numeros" llegue a "5",... deten y salte del bucle completamente. 

            console.log(numeros[i]);

            // Como el "break" lo llame primero que el "console.log", entonces, el "5" no logra imprimirse; pues, antes de llegar al "console.log", ya nos habríamos salido del bucle en sí (por lo que no podría imprimirse más nada).
        }

        // Si se fija bien, y asistiendonos de la estructura de control "if", hemos establecido con la sentencia "break" que se detenga el incremento sobre los elementos del bucle "numeros" cuando el elemento sea equivalente al número "5"; es decir, como puede ver, lo que hace "break" es detener la ejecución del código, "se sale de la estructura en la que está"... Sin embargo, si usted desea, esto puede no ser de forma definitiva; es decir, si usted desea, puede establecer qué es lo que puntualmente quiere que no se ejecute dento de la estructura (en este caso, bucle) y que luego, inmediatamente, la estructura retorne su curso con normalidad. Lo anterior se logra con la sentencia "continue" y, generalmente, se establece el punto que se pretende "volar" o "saltar" (o los puntos por medio de un patrón lógico), de la estructura evaluada (en este caso, un bucle), asistiendose de una estructura de control o condicional (mayormente del tipo "if"). Veamos esto en el mismo caso.

        for (let i= 0; i < numeros.length; i++){
            if (numeros[i] === 5){
                continue;
            }

            // La orden es la siguiente: Apenas el incremento del arreglo "numeros" llegue a "5",... deten el bucle,... pero no te salgas completamente de él, salte o "vuelate" del "5"; y, posteriormente, sigue ejecutando el resto de la estructura. 

            console.log(numeros[i]);

            // Como el "continue" lo llame primero que el "console.log", entonces, el "5" no logrará imprimirse; pues, antes de llegar al "console.log", ya nos habríamos "saltado" al "5" en cuestión (por lo que no podría imprimirse ese valor puntualmente,... aunque luego la estructura, en este caso ciclica, retome su curso).
        }

        // Ejercicio: Imprima sólo los números pares de una lista elaborada con un Array.

        console.log("Ejercicio: Imprimir sólo numeros pares.");

        for (let i= 0; i < numeros.length; i++){
            if (numeros[i] % 2 === 1){
                continue;
            }

            console.log(numeros[i]);
        }
    </script>
</body>
</html>