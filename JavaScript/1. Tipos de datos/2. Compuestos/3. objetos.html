<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Objetos</title>
</head>
<body>
    <script>
        // Los objetos, al igual que los arreglos, se pueden declarar con el tipo de dato "const" (no solo con "let"); de hecho, es lo ideal en ambos casos (que se declaren con "const"); pues, con "const" si bien no estamos limitados a realizar cambios internamente dentro del dominio de los arreglos u objetos, a lo largo de la vida del código, que es lo que se busca; sí es, definitivamente, una buena práctica no cambiar el identificador de ellos; pues bien, con "const" nos aseguramos de que eso nunca pase; es decir, el objeto en un principio declarado con el nombre de "b", a lo largo del código, siempre se llamará "b" y no le podríamos cambiar dicha referencia. Entonces, al yo declarar mi objeto con "const", evito que otro objeto ocupe la referencia que en memoria tiene mi objeto.

        // declaración de Objeto:

        const b = {};
        console.log(b);

        // declaración de Objeto con el constructor "Object" (no muy usado):

        const c = new Object();
        console.log(c);    

        // Ahora, en teoría, un Objeto es una colección de llaves valores; más precisamente, los valores de un Objeto son Atributos o Propiedades (a excepción de las funciones que defina dentro de un Objeto, eso será siempre una función o "método"); entonces, dichos "Atributos" son como las variables que tiene dentro un Objeto. Estructuralmente un Objeto de JS se parece mucho a una Regla de CSS; por lo menos, en su escritura. Vamos a probarlo:

        const yo = {
            nombre: "Roberto",
            apellidos: "Velasquez Dean",
            edad: 25,
            sexo: 'M',
            pasatiempos: ["Leer", "Dormir", "Jugar"],
            soltero: true,
            contacto: {
                email: "robertovelasquezdean@gmail.com",
                twitter: "@Rescata__",
                facebook: "Roberto Velasquez Dean",
                movil: "3016206459"
            },
            saludar: function (){
                console.log("Hola :)")
            },
            decirMiNombre: function (){
                console.log(`Hola me llamo ${this.nombre} ${this.apellidos}, tengo ${this.edad} años y me puedes seguir como ${this.contacto.twitter} en Twitter.`)

                // Hemos hecho uso del recurso "this" para dejar claro sobre qué ambito de existencia o alcance estoy trabajando; en este caso, como ya estoy dentro del Objeto "yo", estamos ante un Alcance o ambito de existencia de bloque; dicho lo anterior, con "this", dejo claro que es sobre ESTE, mi objeto "yo", donde voy a trabajar y del cual me voy a referenciar; entonces, de ESTE bloque (porque estoy dentro de él y lo estoy referenciando con THIS) me interesa trabajar con sus valores (atributos) "nombre", "apellidos" y "edad"; en este caso puntual, cuando se quiera hacer uso de una propiedad o atributo que esté dentro de un Objeto (y que se está empleando dentro de dicho Objeto) se debe hacer uso del recurso "this"... para dejar claro que el valor lo estoy tomando de ESTE objeto y no de un ambito de existencia global.
            }
        }

        console.log(yo);

        // Los Objetos, interiormente, pueden estar compuestos por valores de distintos tipos de datos; incluso, dentro de un Objeto puede haber otro Objeto o, también, una función,... tal como lo hicimos con nuestro ejemplo, en su orden tenemos: 

            // 1. String
            // 2. String
            // 3. Number
            // 4. Caracter
            // 5. Arreglos
            // 6. Booleano
            // 7. Objeto
            // 8. Función.
            // 9. Función con Template String.

        // Ahora, cómo podemos acceder a cada uno de los 8 valores del Objeto "yo"? Es similar a como lo hacía con los Arreglos (Arrays). Recuerde: en los tipos de datos "Compuestos" tales como: "Arreglo", "Función" u "Objeto",... no se accede directamente a un univalor, no; sino, se accede a una referencia; pues, los tipos de datos compuestos no se definen con un único valor.

        // La diferencia de los Objetos, en relación a los Arreglos, es que acá no se accede a los valores por medio de "posiciones"; sino, pasando el propio nombre del valor de nuestro interés en sí, al que queremos acceder, tal que así: 

        console.log(yo["nombre"]);
        // o así (es lo mismo):
        console.log(yo.nombre);

        console.log(yo["pasatiempos"]);
        // o así:
        console.log(yo.pasatiempos);

        // Ahora, si quiero acceder propiamente a un valor del arreglo "pasatiempos", que está dentro de mi Objeto "yo", cómo sería? Pues bien, como ahora estaríamos frente a un Arreglo (convengamos que ya accedimos a él en el anterior "console.log"), ahora sí tiene sentido pasar posiciones para acceder al valor o elemento de su interés; pues, como se dijo, ya estaría frente a un Arreglo. Tal que así:

        console.log(yo["pasatiempos"][1]);  
        // Hemos accedido a "Dormir", nuestro 2do elemento del Array "pasatiempos". Lo mismo que decir: 
        console.log(yo.pasatiempos[1]);
        
        // Cómo sería si quisiera acceder a un valor del Objeto "contacto" que está dentro del Objeto "yo"; pues bien, es la misma lógica, sólo que como usted ya sabe... para buscar valores dentro de un Objeto no se pasan posiciones; sino, el nombre propio del valor (atributo o propiedad) como tal. Veamos esto. Quiero acceder al atributo o propiedad "twitter" del Objeto "contacto" que está dentro de mi Objeto principal "yo". Tal que así:

        console.log(yo["contacto"]["twitter"]);
        // o así...
        console.log(yo.contacto.twitter);

        // Ahora, como las funciones dentro de un Objeto no es lo mismo que los demás tipos de datos que pueda contener el Objeto en sí; es decir, los demás valores son Atributos o propiedades; mientras que, la funciones siempre serían métodos... Entonces, las funciones, para acceder a ellas, se llaman necesariamente de otra manera; recuerde que, una función se invoca entre parentesis "funcion();". Ahora, invocar una función que está dentro de un Objeto sería así: "Objeto.funcion();" Tal que así:

        yo.saludar();
        // no se le pasa un "console.log" porque, ya por sí, la función tiene por dentro un "console.log". Probemos con la otra función.

        yo.decirMiNombre();

        // Algunos métodos de los Objetos.
        
        // El prototipo "Object", de los Objetos, tiene un par de métodos interesantes que vamos a revisar... Su estructura, para ser invocados, puede en muchos casos ser así: "Object.método(objeto_de_interés)". Veamos algunos haciendo uso de la función "console.log();"

        // 1. "Object.keys()": es un método del prototipo "Object" que consiste en "enlistarnos", por medio de un Arreglo iterable con sus respectivas posiciones, todas las llaves (atributos/propiedades & funciones) por las que se compone un Objeto en sí; en este caso, el objeto de nuestro interés es: "yo". Veamos.

        console.log(Object.keys(yo));

        // 2. "Object.values()": hace exactamente lo mismo que "Object.keys()"; solo que, ahora, lo enlistado serán los valores de las llaves, mas no las llaves en sí. Veamos.

        console.log(Object.values(yo));

        // 3.  es un método que nos permite saber si un Objeto, dentro de él, tiene X o Y propiedad/atributo; es decir, nos permite consultar, por medio del nombre, si dentro de un Objeto existe cierta propiedad. En caso que exista la propiedad pasada, la salida será una respuesta en booleano diciendo: "true"; de lo contrario, si no existe la propiedad, la salida será un "false". Veamos.

        console.log(yo.hasOwnProperty("nombre"));
        // El resultado es "true" porque el objeto "yo", dentro de sí, tiene efectivamente una propiedad llamada: "nombre".

        // Probemos buscando una propiedad que no exista dentro de mi objeto "yo".

        console.log(yo.hasOwnProperty("pareja"));
    </script>
</body>
</html>