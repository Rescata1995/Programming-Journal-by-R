<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estructuras Repetitivas</title>
</head>
<body>
    <p>
        Cuando por medio de pocas líneas de código, y asistiendose generalmente de un "incrementador" o "contador" (en contubernio con una variable índice), podemos hacer que se ejecute repetitivamente cierto dominio o bloque de código -propio de un bucle- mientras se mantenga valida o cumpliendo cierta condición... hablamos de: "Estructuras ciclicas" o "repetitivas"; todo esto, aclaremos, sin tener que escribir dos veces el dominio en cuestión que queremos que se ejecute iterativamente.
    </p>

    <p>
        Uno habla de "incrementador" o "contador" para no entrar en un ciclo o bucle infinito; es decir, para que una condición pasada no sea siempre valida, pues, es el "contador" quién tiene la capacidad de limitar la validez de dicha condición. En efecto, quién va a controlar que un bucle o ciclo no sea infitivo es precisamente el incremento o decremento, generalmente en una unidad (con incrementadores unarios), que asume la variable afectada por dicho "contador" o "incrementador" en cada iteracción del bucle; a esta variable se le suele llamar "índice". Entonces, la variable "índice" va a incrementar (o decrementar) hasta que la condición deje de ser valida,... al comparar ambas. Finalmente el programa, en consecuencia, sale del bucle y deja de ejecutar repetitivamente su dominio o bloque de código.
    </p>

    <p>
        Tenemos varios tipos de bucles, por ejemplo: While, do-while, for y un par de nuevos más como: for in & for of. Veamos un ejemplo cada uno.
    </p>
    <script>  

    // Ejemplo con "While"

    let contador = 0; 

    while (contador < 10){
        console.log(contador);
        contador++; // Uso de incrementador unario.
    }

    // Nos imprime, desde el 0, hasta el número 9; pues, la condición para que el bucle no dejará de funcionar iterativamente era que 10 fuera mayor que la variable "contador" (contador < 10); entonces, como con cada iteracción se incrementa en una unidad el valor de "contador", que inicialmente era 0, llegará un punto en que "contador" será mayor o igual que 10 (contador >= 10)... apenas eso pase la condición del bucle dejará de ser valida; por lo que, en consecuencia, el programa se saldrá del bucle mismo.

    // -----------------------------------

    // Ejemplo con "Do-while"

    // Hay otra estructura, muy parecida a "While", que es "Do-while". "Do-while" básicamente hace lo mismo que "While"; sin embargo, la diferencia de ambos radica en una sóla cosa y es lo siguiente: La estructura "Do-while" ejecutará, al menos una vez, el dominio o bloque de código del bucle sin importar si es valida o no la condición pasada dentro del mismo. Es decir, en la estructura ciclica o repititiva "do-while" lo que primero se ejecuta es su dominio o bloque de código, el que contiene, sin antes evaluar primeramente la validez de la condición (cosa que sí ocurre con "While"). 
    
    // Ahora, que el bucle "Do-while" se comporte de esta forma diferente no es ninguna coincidencia, pues, estructuralmente (y respetando el orden del código) lo que primero se ejecuta, dentro de un "Do-while", es su bloque de código o dominio y posteriormente su condición. Veamos esto.

    // Actualmente tenemos que la variable "contador" asume un valor de 10.

    do {
        console.log("do while " + contador);
        contador++;
    } while (contador < 10);

    // Siempre se ejecutará, al menos una sola vez, el dominio o bloque de código de la estructura repetitiva "Do-while"; esto, incluso, aunque no se cumpla su propia condición (se ejecutará siempre, en todos los casos, una vez).

    // -----------------------------------
  
    // Ejemplo con "For"

    // El ciclo o bucle "for", como estructura repetitiva, es el más utilizado y consta de tres partes (Realmente hace lo mismo que "While",... sólo que se representa con otra estructura). 
    
    // Ahora, que el bucle "for" sea la estructura repetitiva más utilizada... quizás tenga que ver con la facilidad de agrupar todos sus recursos dentro de una sola línea de código; ojo, con esto no me refiero ni al dominio ni el bloque de código que se pretende ejecutar; sino: 1. A la variable "índice", 2. La condición a evaluar & 3. el "incrementador" o "contador" en sí. La variable índice suele ser declarada con una "i". Acá la estructura modelo:

    // for (let index = 0; index < array.length; index++) {
    //     const element = array[index];
    // }

    for (let i = 0; i < 10; i++) {
        console.log("for " + i);  
    }

    // Nos imprime, desde "for 0", hasta el "for 9"; pues, la condición para que el bucle no dejará de funcionar iterativamente era que 10 fuera mayor que "i" (i < 10); entonces, como con cada iteracción se incrementa en una unidad el valor de "i", que inicialmente era 0, llegará un punto en que "i" será mayor o igual que 10 (i >= 10)... apenas eso pase la condición del bucle dejará de ser valida; por lo que, en consecuencia, el programa se saldrá del bucle mismo.

    // Ahora, hay una relación de "amor" entre los bucles "for" & los "arrays"; pues, resulta que con un bucle "for" podemos pasar por, y quizás imprimir, todos los valores de las posiciones de un Arreglo. Esto se entiende mucho mejor con un ejemplo.

    let numeros = [10, 20, 30, 40, 50, 60, 70, 80];

    for (let index = 0; index < numeros.length; index++) {
        console.log(`Este es el número: ${numeros[index]}.`);
    }

    // La expresión ".length", al final de "numeros", es una propiedad que determina numericamente la cantidad de elementos que tiene un arreglo; en este caso, como estamos hablando de "numeros", serían 8 elementos... lo mismo que decir 7 posiciones (debe saber el porqué). Entonces, si quiero que mi limite de iteracciones sea correspondiente a la totalidad de elementos que tiene mi arreglo, hasta llegar a su último, puedo valerme de dicha propiedad "length" para formular mi condición; dicha condición, cómo máximo, hará que mi bucle itere hasta el último elemento de mi arreglo,... a la última posición del mismo mientras (y aquí mi condición) "index < numeros.length".

    // Con un incrementador unario, entonces, acá también incrementamos en una unidad al "index" y que itere el bucle hasta que "index < numeros.length".

    // Ahora, si sabemos que la posición 0 de un arreglo corresponde a su 1er elemento; es decir, en este caso, "numeros[0]" equivale a "10"; y, adicionalmente, hemos inicializado al "index" con un "0" también,... podemos jugar con esto! Por ejemplo, si quisieramos que con cada iteracción se nos mostrarán todos los elementos de un Arreglo, uno por uno, por medio de un bucle "for", podemos hacerlo. Para este caso puntual, para lograr lo anterior... sería imprimiendo cada posición del Arreglo "numeros" con asistencia de la variable "index"; la cual, si recuerda, es la que se incrementará en una unidad cada que itere el bucle; entonces, con cada iteracción se pasa, por medio de "index", por todas las posiciones del Arreglo de interés, en este caso, "numeros". Fue lo que hicimos justamente más arriba.

    // -----------------------------------
  
    // Variantes del Bucle For: "For in" & "For of"

    // A. For in

    // El "For in" es un Loop (bucle) que me va a permitir recorrer o iterar las propiedades de un Objeto; es decir, es un "For" diseñado para iterar sobre las llaves valores (propiedades o atributos) que tiene el tipo de dato compuesto que se llama: "Objeto". 

    // Recuerde que las llaves valores de un Objeto hacen referencia a todos los tipos de datos/variables que tiene por dentro (con sus respectivos valores inicializados). Ahora, revisemos la estructura más básica de un bucle de tipo "For in", es así:

    // for (const key in object) {
        
    // }

    // Donde en "key" se coloca el nombre que va a recibir (o para referenciar), dentro del bucle, el conjunto de las propiedades del Objeto, de nuestro interés, que va a ser manipulado. Ahora, para hacer referencia propiamente al identificador del Objeto que nos interesa manipular, el nombre del mismo debe colocarse en "object".

    // Veamos todo esto en un ejemplo. Declaremos un Objeto.

    const person = {
        nombre: "Roberto",
        apellido: "Velasquez",
        edad: 25
    }

    // Ahora, declaremos un "For in" para recorrer todas las 3 propiedades o atributos del Objeto "person". En este caso, particularmente, las vamos a recorrer para mostrarlas (mostrar sus "keys", es decir, sus propiedades). Solamente se verán las propiedades del Objeto "person" porque solamente mostraremos eso; pues, imprimiremos sólo la parte del "key" de dicho bucle "For in"; es decir, la parte que referencia a todas las propiedades y las recorre en cada iteracción; en este caso, estamos hablando de las propiedades del Objeto "person".

    for (const propiedades in person) {
        console.log(propiedades);
    }

    // Ahora, si nos interesa también, por ejemplo, imprimir; además de todas las propiedades, sus respectivos valores (del Objeto "person")... Tenemos que llamar de alguna manera, dentro del bucle "For in", la totalidad de los valores para cada una de las propiedades del Objeto "person". Al igual, no dejemos de mostrar a la propiedad en sí.

    // Ahora, para recorrer o iterar sobre todos los valores de las propiedades de un Objeto, en un bucle "For in", se debe llamar al identificador del Objeto en sí y, adicionalmente, ahí pegado, pasarle entre llaves [] el nombre que le dimos a nuestra "key" dentro del bucle "for in" que está manipulando al Objeto de nuestro interés. 
    
    // Recuerde, "key" es quien referencia al conjunto de las propiedades del Objeto manipulado; en este caso, al Objeto manipulado "person" le pasamos un "key" con el nombre de "propiedades". Imprimamos ahora los valores para el Objeto "person" (con la impresión de la propiedad o atributo mismo).

    for (const propiedades in person) {
        console.log(`Yo soy la propiedad: "${propiedades}" y mi valor es: ${person[propiedades]}`);
    }

    // Hemos impreso, por medio de Template Strings, tanto las propiedades del Objeto "person" como sus respectivos valores. 

    // De momento, entonces, el bucle "For" clásico nos sirve para recorrer elementos de un Array & el Bucle "For in" nos sirve para recorrer, especificamente, propiedades de un Object, de dicho tipo de dato compuesto.

    // Sin embargo "For of", nuestra 2da variante del bucle For, va más allá... nos permite recorrer todos los elementos de cualquier Objeto que sea iterable en JS; es decir, esta vez no nos concentramos solamente en el tipo de dato compuesto que se le llama: "Object" (Objecto), no; sino, en todo lo que se concibe como Objeto en JS, como por ejemplo un String. Recuerde que "Todo en JS es un Objeto".

    // B. For of

    // la estructura más básica de un bucle de tipo "For of", es así:

    // for (const iterator in object) {
        
    // }

    // Donde en "iterator" se coloca el nombre que va a recibir (o para referenciar), dentro del bucle, el conjunto de los elementos del Objeto (cualquiera que sea iterable en JS) que será manipulado. Ahora, para hacer referencia propiamente al identificador del Objeto que nos interesa manipular, el nombre del mismo debe colocarse en "object".

    // Pongamos en práctica un bucle "For of" dentro del Array "numeros", con el que ya habíamos trabajado anteriormente, para que se impriman todos sus elementos; es decir, todos sus números al recorrer cada uno de ellos con "For of".
    
    // Aclaración: un Array vendría siendo un Objeto también y que, además, cumple con la condición de ser iterable en JS). 

    for (const elementos of numeros) {
        console.log(elementos);
    }

    // Sólo fue necesario llamar al "iterator", del bucle "For of", para que hiciera un recorrido por todos los elementos del Objeto de nuestro interés (y los imprimiera con "console.log"); en este caso, el Objeto manipulado es: "numeros" y el nombre pasado al "iterator" fue "elementos".

    // "For of", si se da cuenta, nos facilita todo el trabajo si quisieramos recorrer todos los elementos de un Array, por ejemplo. Sin embargo, también podemos trabajar un String con un bucle "For of". Se sabe que un String, además de ser un Objeto dentro de JS, es también iterable; pues, una cadena de texto se compone por caracteres; en consecuencia, podemos pasar por cada uno de ellos, sus elementos, por medio de iteraciones. Veamos.

    let cadena = "Hola Mundo";

    for (const elementos of cadena) {
        console.log(elementos);
    }

    // Cuando hablamos de "iterable" nos referimos a la capacidad que tenemos de partir un Objeto en varios elementos, varios elementos que no dejan de ser propios al Objeto de interés en sí.
    
    </script>
</body>
</html>